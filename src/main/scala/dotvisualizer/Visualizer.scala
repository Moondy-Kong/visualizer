// See LICENSE for license details.

package dotvisualizer

import java.io.PrintWriter

import chisel3.experimental
import chisel3.experimental.{ChiselAnnotation, RunFirrtlTransform}
import chisel3.internal.InstanceId
import firrtl.CompilerUtils.getLoweringTransforms
import firrtl.PrimOps._
import firrtl._
import firrtl.analyses.InstanceGraph
import firrtl.annotations._
import firrtl.ir._
import firrtl.passes.Pass
import firrtl.transforms.BlackBoxSourceHelper


import firrtl.Utils._
import firrtl.Mappers._


import scala.collection.mutable
import sys.process._

//TODO: Chick: Allow specifying where to write dot file
//TODO: Chick: Allow way to suppress or minimize display of intermediate _T nodes
//TODO: Chick: Consider merging constants in to muxes and primops, rather than wiring in a node.

//TODO: MONICA: Implement depth

//scalastyle:off magic.number
/**
  * This library implements a graphviz dot file render.  The annotation can specify at what module to
  * start the rendering process.  value will eventually be modified to allow some options in rendering
  */

/**
  * Tools for creating annotations for direct processing of a firrtl input file.
  */
object VisualizerAnnotation {
  /**
    * Use this to create an firrtl annotation,
    * @param target  The module to start rendering
    * @param depth   Stop rendering after this many sub-modules have been descended. 0 just does IOs of target
    *                1 does all components of current target, plus IOs of submodules referenced,
    *                and so forth.
    * @return
    */
  def apply(target: Named, depth: Int = -1): VisualizerAnnotation = {
    VisualizerAnnotation(target, s"${Visualizer.DepthString}=$depth")
  }

  /**
    * Use this to set the program to convert the dot file to a png.  dot and fdp seem to work well, others
    * might too.  Default is dot
    * @param program program to create png
    * @return
    */
  def setDotProgram(program: String): Annotation = {
    VisualizerAnnotation(CircuitName("Visualizer"), s"${Visualizer.DotProgramString}=$program")
  }

  /**
    * Use this to set the program to create multiple files, one for each mod.  dot and fdp seem to work well, others
    * might too.  Default is dot
    * @param program program to create png
    * @return
    */
  def setVisualizeAll(program: Boolean): Annotation = {
    VisualizerAnnotation(CircuitName("Visualizer"), s"${Visualizer.MultiGraph}=$program")

  }

  /**
    * Use this control what program will be called with the png file as its command line argument.
    * On OS-X open will launch the default viewer (usually preview)
    * Set program to none to turn off this feature
    * @param program program to open png
    * @return
    */
  def setOpenProgram(program: String): Annotation = {
    VisualizerAnnotation(CircuitName("Visualizer"), s"${Visualizer.OpenProgramString}=$program")
  }

  /**
    * Change the output format generated by dot
    * @param format format should be one of jpg, png or svg.  Others may be possible
    * @return
    */
  def setOutputFormat(format: String): Annotation = {
    VisualizerAnnotation(CircuitName("Visualizer"), s"${Visualizer.OpenProgramString}=$format")
  }

//  def unapply(a: Annotation): Option[(Named, String)] = a match {
//    case VisualizerAnnotation(named, value) =>
//      Some((named, value))
//    case _ => None
//  }
}

case class VisualizerAnnotation(target: Named, value: String) extends SingleTargetAnnotation[Named] {
  override def duplicate(n: Named): Annotation = this.copy(target = n)
}

case class VisualizerChiselAnnotation(
  target: InstanceId,
  value: String
) extends ChiselAnnotation with RunFirrtlTransform {

  override def toFirrtl: Annotation = VisualizerAnnotation(target.toNamed, value)

  override def transformClass: Class[_ <: Transform] = classOf[VisualizerTransform]

}

/**
  * Add this trait to a module to allow user to specify that the module or a submodule should be
  * rendered
  */
trait VisualizerAnnotator {
  self: chisel3.Module =>

  /**
    * Use this to create an firrtl annotation,
    * @param component  The module to start rendering
    * @param depth      Stop rendering after this many sub-modules have been descended. 0 just does IOs of target
    *                   1 does all components of current target, plus IOs of submodules referenced,
    *                   and so forth.
    * @return
    */
  def visualize(component: InstanceId, depth: Int = 0): Unit = {
    experimental.annotate(
      VisualizerChiselAnnotation(component, s"${Visualizer.DepthString}=$depth")
    )
  }
  /**
    * Use this to set the program to convert the dot file to a png.  dot and fdp seem to work well, others
    * might too.  Default is dot
    * @param program program to create png
    * @return
    */
  def setDotProgram(program: String): Unit = {
    experimental.annotate(
      VisualizerChiselAnnotation(self, s"${Visualizer.DotProgramString}=$program")
    )
  }
  /**
    * Use this control what program will be called with the png file as its command line argument.
    * On OS-X open will launch the default viewer (usually preview)
    * Set program to none to turn off this feature
    * @param program program to open png
    * @return
    */
  def setOpenProgram(program: String): Unit = {
    experimental.annotate(
      VisualizerChiselAnnotation(self, s"${Visualizer.OpenProgramString}=$program")
    )
  }
}

class RemoveUselessGenTPass() extends Pass {

  val toRemove = new mutable.HashMap[String, Expression]()

  //scalastyle:off method.length cyclomatic.complexity
  def run(c: Circuit): Circuit = {

    def collectGenExpr(s: Statement): Option[Statement] = s match {
      case block: Block =>
        val result = Some(Block(block.stmts.flatMap{ substatement =>
          collectGenExpr(substatement)
        }))
        result

      case node: DefNode =>
        if (node.name.startsWith("_GEN") || node.name.startsWith("_T")) {
          toRemove(node.name) = node.value
          None
        } else {
          Some(node)
        }
      case _ => Some(s) //do nothing
    }

    def removeGen(e: Expression): Expression = {
      e match {
        case wire: WRef =>
          if ((wire.name.startsWith("_GEN") || wire.name.startsWith("_T")) && toRemove.contains(wire.name)) {
            val new_node = toRemove(wire.name)
            removeGen(new_node)
          } else {
            wire
          }
        case wire: WSubField =>
          if ((wire.name.startsWith("_GEN") || wire.name.startsWith("_T")) && toRemove.contains(wire.name)) {
            val new_node = toRemove(wire.name)
            removeGen(new_node)
          } else {
            wire
          }
        case wire: WSubIndex =>
          wire.mapExpr(removeGen)
        case ee => ee.mapExpr(removeGen)
      }
    }

    def removeGenStatement(s: Statement): Option[Statement] = {
      s match {
        case block: Block =>
          val result = Some(Block(block.stmts.flatMap{ substatement =>
            removeGenStatement(substatement)
          }))
          result
        case node: DefNode =>
          if (node.name.startsWith("_GEN") || node.name.startsWith("_T")) {
            None
          } else {
            Some(node)
          }
        case other: Statement =>
          Some(other.mapExpr(removeGen))
        case _ => Some(s) //do nothing
      }
    }

    var newModules = c.modules.map {
      case m: Module => Module(m.info, m.name, m.ports, collectGenExpr(m.body).get)
    }

    newModules = newModules.map { m: Module =>
        val new_body =  removeGenStatement(m.body).get
        Module(m.info, m.name, m.ports, new_body)
    }

    Circuit(c.info, newModules, c.main)
  }
}

/**
  * Represents a module instance in the graph of instances in a circuit.
  * @param graphName    How `dot` will refer to this node
  * @param instanceName The instance name within the parent module
  * @param moduleName   The Module Name
  */
class ModuleDotNode private (val graphName: String, val instanceName: String, val moduleName: String) {
  val children = new mutable.ArrayBuffer[ModuleDotNode]()

  /**
    * Render this node as a small HTML table with the module name at the top
    * and each child instance as a row
    * children are sorted by moduleName then instanceName
    * @return
    */
  def render: String = {
    val s = new mutable.StringBuilder()
    s.append(s"""$graphName [shape= "plaintext" """)
    s.append(s"""label=<\n""")
    s.append(
      """
        |<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4" >
        """.stripMargin)

     s.append(
       s"""
        |  <TR >
        |    <TD BGCOLOR="#FFDEAD" > $moduleName </TD>
        |  </TR>
        """.stripMargin)

     children.sortBy { child => s"${child.moduleName} ${child.instanceName}" }.foreach { child =>
       s.append(
         s"""
            |  <TR>
            |    <TD PORT="${child.graphName}" BGCOLOR="#FFF8DC" >${child.instanceName}</TD>
            |  </TR>
        """.stripMargin)
     }

     s.append(
       s"""
        |</TABLE>>];
        |
      """.stripMargin)
    s.toString
  }
}

/**
  * Is the factory for ModuleDotNode creation
  */
object ModuleDotNode {
  var nodeCounter: Int = 0

  /**
    * This factor created a new unique dot graph node name for this instance
    * @param instanceName The instance
    * @param moduleName   The module
    * @return
    */
  def apply(instanceName: String, moduleName: String): ModuleDotNode = {
    nodeCounter += 1
    new ModuleDotNode(s"module_$nodeCounter", instanceName, moduleName)
  }
}

/**
  * Creates a high level graph that shows the instances in the circuit and their Module names
  * @param targetDir  directory where dot graph will end up
  * @param nameOfFile file name in that directory
  */
//
//TODO: Make even more links from these graph nodes back to the other generated graphs
//
class TopLevelModPass(targetDir: String, nameOfFile: String) extends Pass {

  def save(fileName: String, dotProgram: String = "dot"): Unit = {
    if(dotProgram != "none") {
      //noinspection SpellCheckingInspection
      val dotProcessString = s"$dotProgram -Tsvg -O $fileName"
      dotProcessString.!!
    }
  }

  def run(c: Circuit) : Circuit = {
    val TopLevel = "TopLevel"

    val moduleNodes = new mutable.ArrayBuffer[ModuleDotNode]()
    val connections = new mutable.ArrayBuffer[(String, String)]()

    val printFile = new PrintWriter(new java.io.File(s"$targetDir$TopLevel.dot"))
    printFile.write("digraph " + TopLevel + " { rankdir=\"TB\" \n node [shape=\"rectangle\"]; \n")
    printFile.write("rankdir=\"LR\" \n")


    //statements that have modules, have a list of module names,

    val top = WDefInstance(c.main, c.main)

    /**
      * Find the given instance in the Module Hierarchy
      * This is almost certainly inefficient. Should not have to map the modules every time
      * @param instance instance being searched for
      * @return
      */
    def findModuleByName(instance: WDefInstance): Set[WDefInstance] = {
      c.modules.find(m => m.name == instance.module) match {
        case Some(module) =>
          val set = new mutable.HashSet[WDefInstance]
          module map InstanceGraph.collectInstances(set)
          set.toSet

        case None => Set.empty[WDefInstance]
      }
    }

    /**
      * Walk through the instance graph adding ModuleDotNodes and a record of their connections
      * @param wDefInstance start instance
      * @param path         underscore separated path to the start instance
      * @return
      */
    def walk(wDefInstance: WDefInstance, path: String = ""): ModuleDotNode = {
      def expand(name: String): String = {
        if(path.isEmpty) name else path + "_" + name
      }

      val dotNode = ModuleDotNode(wDefInstance.name, wDefInstance.module)
      moduleNodes += dotNode

      val children = findModuleByName(wDefInstance)
      children.foreach { child =>
        val childNode = walk(child, expand(wDefInstance.name))
        connections.append((dotNode.graphName + ":" + childNode.graphName, childNode.graphName))
        dotNode.children += childNode
      }

      dotNode
    }

    // Start walk from the top of the graph
    walk(top)

    // Render all the collected nodes
    for(mod <- moduleNodes) {
      printFile.append(mod.render)
    }

    // Render their connections
    for((parent, child) <- connections) {
      printFile.write(s"$parent -> $child\n")
    }

    // Add the back button
    printFile.write("\"Back\" [URL=\"" + nameOfFile + ".dot.svg\" ]")
    printFile.write("}")

    // Finish writing the file
    printFile.close()
    save(s"$targetDir$TopLevel.dot")

    c
  }

}



/**
  * Annotations specify where to start rendering.  Currently the first encountered module that matches an annotation
  * will start the rendering, rendering continues per the depth specified in the annotation.
  * This pass is intermixed with other low to low transforms, it is not treated as a separate
  * emit, so if so annotated it will run with every firrtl compilation.
  *
  * @param annotations  where to start rendering
  */
//noinspection ScalaStyle
class VisualizerPass(val annotations: Seq[Annotation], targetDir: String = "", startModuleName : String) extends Pass {

  val subModulesFound = new mutable.HashSet[DefModule]()

  def run (c:Circuit) : Circuit = {
    val nameToNode: mutable.HashMap[String, DotNode] = new mutable.HashMap()

    val printFile = new PrintWriter(new java.io.File(s"$targetDir$startModuleName.dot"))
    def pl(s: String): Unit = {
      printFile.println(s.split("\n").mkString("\n"))
    }

    /**
      * finds the specified module name in the circuit
      *
      * @param moduleName name to find
      * @param circuit circuit being analyzed
      * @return the circuit, exception occurs in not found
      */
    def findModule(moduleName: String, circuit: Circuit): DefModule = {
      circuit.modules.find(module => module.name == moduleName) match {
        case Some(module: firrtl.ir.Module) =>
          module
        case Some(externalModule: DefModule) =>
          externalModule
        case _ =>
          throw new Exception(s"Could not find top level module in $moduleName")
      }
    }

    /**
      * If rendering started, construct a graph inside moduleNode
      * @param modulePrefix the path to this node
      * @param myModule     the firrtl module currently being parsed
      * @param moduleNode   a node renderable to dot notation constructed from myModule
      * @return
      */
    def processModule(
                       modulePrefix: String,
                       myModule: DefModule,
                       moduleNode: ModuleNode,
                       scope: Scope = Scope()
                     ): DotNode = {
      /**
        * Half the battle here is matching references between firrtl full name for an element and
        * dot's reference to a connect-able module
        * Following functions compute the two kinds of name
        */

      /** get firrtl's version, usually has dot's as separators
        * @param name components name
        * @return
        */
      def getFirrtlName(name: String): String = {
        if(modulePrefix.isEmpty) name else modulePrefix + "." + name
      }

      def expand(name: String): String = {
        s"${moduleNode.absoluteName}_$name".replaceAll("""\.""", "_")
      }

      def getLiteralValue(expression: Expression): Option[String] = {
        expression match {
          case UIntLiteral(x, _) => Some(x.toString)
          case SIntLiteral(x, _) => Some(x.toString)
          case _                 => None
        }
      }

      def processPrimOp(primOp: DoPrim): String = {
        def addBinOpNode(symbol: String): String = {
          val arg0ValueOpt = getLiteralValue(primOp.args.head)
          val arg1ValueOpt = getLiteralValue(primOp.args.tail.head)

          val opNode = BinaryOpNode(symbol, Some(moduleNode), arg0ValueOpt, arg1ValueOpt)
          moduleNode += opNode
          if(arg0ValueOpt.isEmpty) moduleNode.connect(opNode.in1, processExpression(primOp.args.head))
          if(arg1ValueOpt.isEmpty) moduleNode.connect(opNode.in2, processExpression(primOp.args.tail.head))
          opNode.asRhs
        }

        def addUnaryOpNode(symbol: String): String = {
          val opNode = UnaryOpNode(symbol, Some(moduleNode))
          moduleNode += opNode
          moduleNode.connect(opNode.in1, processExpression(primOp.args.head))
          opNode.asRhs
        }

        def addOneArgOneParamOpNode(symbol: String): String = {
          val opNode = OneArgOneParamOpNode(symbol, Some(moduleNode), primOp.consts.head)
          moduleNode += opNode
          moduleNode.connect(opNode.in1, processExpression(primOp.args.head))
          opNode.asRhs
        }

        primOp.op match {
          case Add => addBinOpNode("add")
          case Sub => addBinOpNode("sub")
          case Mul => addBinOpNode("mul")
          case Div => addBinOpNode("div")
          case Rem => addBinOpNode("rem")

          case Eq  => addBinOpNode("eq")
          case Neq => addBinOpNode("neq")
          case Lt  => addBinOpNode("lt")
          case Leq => addBinOpNode("lte")
          case Gt  => addBinOpNode("gt")
          case Geq => addBinOpNode("gte")

          case Pad => addUnaryOpNode("pad")

          case AsUInt => addUnaryOpNode("asUInt")
          case AsSInt => addUnaryOpNode("asSInt")

          case Shl => addOneArgOneParamOpNode("shl")
          case Shr => addOneArgOneParamOpNode("shr")

          case Dshl => addBinOpNode("dshl")
          case Dshr => addBinOpNode("dshr")

          case Cvt => addUnaryOpNode("cvt")
          case Neg => addUnaryOpNode("neg")
          case Not => addUnaryOpNode("not")

          case And => addBinOpNode("and")
          case Or  => addBinOpNode("or")
          case Xor => addBinOpNode("xor")

          case Andr => addUnaryOpNode("andr")
          case Orr  => addUnaryOpNode("orr")
          case Xorr => addUnaryOpNode("xorr")

          case Cat => addBinOpNode("cat")

          case Bits =>
            val opNode = OneArgTwoParamOpNode("bits", Some(moduleNode), primOp.consts.head, primOp.consts.tail.head)
            moduleNode += opNode
            moduleNode.connect(opNode.in1, processExpression(primOp.args.head))
            opNode.asRhs


          case Head => addOneArgOneParamOpNode("head")
          case Tail => addOneArgOneParamOpNode("tail")

          case _ =>
            "dummy"
        }
      }

      def processExpression(expression: firrtl.ir.Expression): String = {
        def resolveRef(firrtlName: String, dotName: String): String = {
            nameToNode.get(firrtlName) match {
              case Some(node) =>
                  node.asRhs
              case _ => dotName
            }
        }


        val result = expression match {
          case mux: firrtl.ir.Mux =>
            val arg0ValueOpt = getLiteralValue(mux.tval)
            val arg1ValueOpt = getLiteralValue(mux.fval)

            val muxNode = MuxNode(s"mux_${mux.hashCode().abs}", Some(moduleNode), arg0ValueOpt, arg1ValueOpt)
            moduleNode += muxNode
            moduleNode.connect(muxNode.select, processExpression(mux.cond))
            if(arg0ValueOpt.isEmpty) moduleNode.connect(muxNode.in1, processExpression(mux.tval))
            if(arg1ValueOpt.isEmpty) moduleNode.connect(muxNode.in2, processExpression(mux.fval))
            muxNode.asRhs
          case WRef(name, _, _, _) =>
              resolveRef(getFirrtlName(name), expand(name))
          case Reference(name, _) =>
              resolveRef(getFirrtlName(name), expand(name))
          case subfield: WSubField =>
            resolveRef(getFirrtlName(subfield.serialize), expand(subfield.serialize))
          case subIndex: WSubIndex =>
            resolveRef(getFirrtlName(subIndex.serialize), expand(subIndex.serialize))
          case validIf : ValidIf =>
            val validIfNode = ValidIfNode(s"validif_${validIf.hashCode().abs}", Some(moduleNode))
            moduleNode += validIfNode
            moduleNode.connect(validIfNode.select, processExpression(validIf.cond))
            moduleNode.connect(validIfNode.in1, processExpression(validIf.value))
            validIfNode.asRhs
          case primOp: DoPrim =>
            processPrimOp(primOp)
          case c: UIntLiteral =>
            val uInt = LiteralNode(s"lit${PrimOpNode.hash}", c.value, Some(moduleNode))
            moduleNode += uInt
            uInt.absoluteName
          case c: SIntLiteral =>
            val uInt = LiteralNode(s"lit${PrimOpNode.hash}", c.value, Some(moduleNode))
            moduleNode += uInt
            uInt.absoluteName
          case other =>
            // throw new Exception(s"renameExpression:error: unhandled expression $expression")
            other.getClass.getName
            ""
        }
        result
      }

      def processPorts(module: DefModule): Unit = {
        def showPorts(dir: firrtl.ir.Direction): Unit = {
          module.ports.foreach {
            case port if port.direction == dir =>
              val portNode = PortNode(port.name, Some(moduleNode), if(moduleNode.parentOpt.isEmpty) 0 else 1)
              nameToNode(getFirrtlName(port.name)) = portNode
              moduleNode += portNode
            case _ => None
          }

        }

        if(scope.doPorts()) {
          showPorts(firrtl.ir.Input)
          showPorts(firrtl.ir.Output)
        }
      }

      def processMemory(memory: DefMemory): Unit = {
        val fName = getFirrtlName(memory.name)
        val memNode = MemNode(memory.name, Some(moduleNode), fName, memory, nameToNode)
        moduleNode += memNode
      }

      def processStatement(s: Statement): Unit = {
        s match {
          case block: Block =>
            block.stmts.foreach { subStatement =>
              processStatement(subStatement)
            }
          case con: Connect if scope.doComponents() =>
            val (fName, dotName) = con.loc match {
              case WRef(name, _, _, _) => (getFirrtlName(name), expand(name))
              case Reference(name, _) => (getFirrtlName(name), expand(name))
              case subfield: WSubField =>
                (getFirrtlName(subfield.serialize), expand(subfield.serialize))
              case subfield: SubField =>
                (getFirrtlName(s.serialize), expand(subfield.serialize))
              case s: WSubIndex => (getFirrtlName(s.serialize), expand(s.serialize))
              case other =>
                println(s"Found bad connect arg $other")
                ("badName","badName")
            }
            val lhsName = nameToNode.get(fName) match {
              case Some(regNode: RegisterNode) => regNode.in
              case Some(memPort: MemoryPort) => memPort.absoluteName
              case _ => dotName
            }
            moduleNode.connect(lhsName, processExpression(con.expr))

          case WDefInstance(_, instanceName, moduleName, _) =>

            val subModule = findModule(moduleName, c)
            val newPrefix = if(modulePrefix.isEmpty) instanceName else modulePrefix + "." + instanceName
            //val url_string = "file:///Users/monica/ChiselProjects/visualizer/src/test/scala/dotvisualizer/" +
            //  info.toString.drop(3).split(" ").head //name of source code file
            //val line_num = info.toString().drop(3).split(" ").tail(0).split(":").head //line # in source code file
            //val subModuleNode = ModuleNode(instanceName, Some(moduleNode), Some(url_string + "#line" + line_num))
            val moduleNameParsed = moduleName.split("/").last
            val subModuleNode = ModuleNode(instanceName, Some(moduleNode), Some(moduleNameParsed + ".dot.svg"))
            moduleNode += subModuleNode

            subModulesFound += subModule

            processModule(newPrefix, subModule, subModuleNode, getScope(moduleName, scope))

          case DefNode(_, name, expression) if scope.doComponents() =>
            val fName = getFirrtlName(name)
            val nodeNode = NodeNode(name, Some(moduleNode))
            moduleNode += nodeNode
            nameToNode(fName) = nodeNode
            moduleNode.connect(expand(name), processExpression(expression))
          case DefWire(_, name, _) if scope.doComponents() =>
            val fName = getFirrtlName(name)
            val nodeNode = NodeNode(name, Some(moduleNode))
            nameToNode(fName) = nodeNode
          case reg: DefRegister if scope.doComponents() =>
            val regNode = RegisterNode(reg.name, Some(moduleNode))
            nameToNode(getFirrtlName(reg.name)) = regNode
            moduleNode += regNode
          case memory: DefMemory if scope.doComponents() =>
            processMemory(memory)
          case _ =>
          // let everything else slide
        }
      }

      myModule match {
        case module: firrtl.ir.Module =>
          processPorts(myModule)
          processStatement(module.body)
        case extModule: ExtModule =>
          processPorts(extModule)
        case a =>
          println(s"got a $a")
      }

      moduleNode
    }

    def getScope(moduleName: String, currentScope: Scope = Scope()): Scope = {
      val applicableAnnotation = annotations.find {
        case annotation : SingleTargetAnnotation[_] =>
          annotation.target match {
            case ModuleName(annotationModuleName, _) =>
              annotationModuleName == moduleName
            case _: CircuitName =>
              currentScope.maxDepth >= 0
            case _ =>
              false
        }
        case _ =>
          false
      }
      applicableAnnotation match {
        case Some(VisualizerAnnotation(_, maxDepthString)) =>
          val maxDepth = maxDepthString.split("=", 2).last.trim.toInt
          Scope(0, maxDepth)
        case _ =>
          currentScope.descend
      }
    }

    findModule(startModuleName, c) match {
      case topModule: DefModule =>
        pl(s"digraph ${topModule.name} {")
        pl("rankdir=\"LR\"")
//        pl(s"graph [splines=ortho];")
        val topModuleNode = ModuleNode(startModuleName, parentOpt = None)
        processModule("", topModule, topModuleNode, getScope(topModule.name))
        pl(topModuleNode.render)
        pl("\"Modules Only View Here\" [URL=\"TopLevel.dot.svg\" shape=\"rectangle\"]; \n")
        pl("}")
      case _ =>
        println(s"could not find top module $startModuleName")
    }

    printFile.close()

    c
  }
}



class VisualizerTransform extends Transform {
  override def inputForm: CircuitForm = LowForm

  override def outputForm: CircuitForm = LowForm

  def show(fileName: String, dotProgram: String = "dot", openProgram: String = "open"): Unit = {
    if(dotProgram != "none") {
      //noinsp
      // ection SpellCheckingInspection
      val dotProcessString = s"$dotProgram -Tsvg -O $fileName"
      dotProcessString.!!

      if(openProgram != "none") {
        val openProcessString = s"$openProgram $fileName.svg"
        openProcessString.!!
      }
    }
  }

  def save(fileName: String, dotProgram: String = "dot"): Unit = {
    if(dotProgram != "none") {
      //noinspection SpellCheckingInspection
      val dotProcessString = s"$dotProgram -Tsvg -O $fileName"
      dotProcessString.!!
    }
  }

  override def execute(state: CircuitState): CircuitState = {
    var dotProgram = "dot"
    var openProgram = "open"
    var doAllGraphs = false

    val targetDir = state.annotations.collectFirst { case x : TargetDirAnnotation => x } match {
      case Some(targetDirAnnotation) => targetDirAnnotation.value + "/"
      case _ => ""
    }

    val filteredAnnotations = state.annotations.flatMap {
      case annotation@VisualizerAnnotation(_, value) =>
        if(value.startsWith(Visualizer.DotProgramString)) {
          dotProgram = value.split("=", 2).last.trim
          None
        }
        else if(value.startsWith(Visualizer.OpenProgramString)) {
          openProgram = value.split("=", 2).last.trim
          None
        }
        else if(value.startsWith(Visualizer.MultiGraph)) {
          //graph all graphs
          doAllGraphs = true
          None
        }
        else {
          Some(annotation)
        }
      case _ => None
    }

    val queue = new mutable.Queue[String]()
    val modulesSeen = new mutable.HashSet[String]()


    val pass_remove_gen = new RemoveUselessGenTPass()
    var circuit = pass_remove_gen.run(state.circuit)

    val pass_top_level = new TopLevelModPass(targetDir, nameOfFile = "TopOfVisualizer")
    pass_top_level.run(state.circuit)

    queue += circuit.main // top level visualizer

    while(queue.nonEmpty) {
      val moduleName = queue.dequeue()
      if (!moduleName.contains(modulesSeen)) {

        val pass = new VisualizerPass(filteredAnnotations, targetDir, moduleName)
        circuit = pass.run(circuit)

        queue ++= pass.subModulesFound.map(module => module.name)
        save(s"$targetDir$moduleName.dot", dotProgram)
      }
    }


    val fileName = s"$targetDir${state.circuit.main}.dot"

    show(fileName, dotProgram, openProgram)


    state
  }
}

object ToLoFirrtl extends Compiler {
  override def emitter: Emitter = new LowFirrtlEmitter
  override def transforms: Seq[Transform] = {
    getLoweringTransforms(ChirrtlForm, LowForm) ++
      Seq(new LowFirrtlOptimization, new BlackBoxSourceHelper)
  }

  def lower(c: Circuit): Circuit = {

    val compileResult = compileAndEmit(firrtl.CircuitState(c, ChirrtlForm))

    compileResult.circuit
  }
}


//TODO: (chick) consider clickable image maps as in
// https://stackoverflow.com/questions/18478559/generate-clickable-dot-graph-for-website

object Visualizer {
  val DepthString       = "Depth"
  val DotProgramString  = "DotProgram"
  val OpenProgramString = "OpenProgram"
  val OutputFormat      = "OutputFormat"
  val MultiGraph        = "Multigraph"

  def run(
    fileName     : String,
    // dotProgram   : String = "fdp",
    dotProgram   : String = "dot",
    openProgram  : String = "open",
    outputFormat : String = "svg"
  ): Unit = {

    val sourceFirrtl = io.Source.fromFile(fileName).getLines().mkString("\n")

    val ast = Parser.parse(sourceFirrtl)


    val loweredAst = ToLoFirrtl.lower(ast)
    val annotations = AnnotationSeq(
      Seq(
        VisualizerAnnotation(CircuitName("Visualizer")),
        VisualizerAnnotation.setDotProgram(dotProgram),
        VisualizerAnnotation.setOpenProgram(openProgram),
        VisualizerAnnotation.setOutputFormat(outputFormat),
        VisualizerAnnotation.setVisualizeAll(true)
      )
    )
    val circuitState = CircuitState(loweredAst, LowForm, annotations)

    val transform = new VisualizerTransform

    transform.execute(circuitState)
  }

  //scalastyle:off regex
  def main(args: Array[String]): Unit = {
    args.toList match {
      case fileName :: dotProgram :: openProgram :: outputFormat :: Nil =>
        run(fileName, dotProgram, openProgram, outputFormat)
      case fileName :: dotProgram :: openProgram :: Nil =>
        run(fileName, dotProgram, openProgram)
      case fileName :: dotProgram :: Nil =>
        run(fileName, dotProgram)
      case fileName :: Nil =>
        run(fileName)
      case _ =>
        println("Usage: Visualizer <firrtl-file> <dot-program> <open-program> <output-format>")
        println("       <dot-program> must be one of dot family circo, dot, fdp, neato, osage, sfdp, twopi")
        println("                     default is dot, use none to not produce output file")
        println("       <open-program> default is open, this works on os-x, use none to not open")
        println("       <output-format> default is svg, typical choices are svg, jpg or png")
    }
  }
}

