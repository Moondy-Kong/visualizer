// See LICENSE for license details.

package dotvisualizer

import java.io.{File, PrintWriter}

import chisel3.experimental
import chisel3.experimental.{ChiselAnnotation, RunFirrtlTransform}
import chisel3.internal.InstanceId
import dotvisualizer.transforms.{MakeDiagramGroup, ModuleLevelDiagrammer}
import firrtl._
import firrtl.annotations._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, Future, TimeoutException, blocking}
import scala.sys.process._

//TODO: MONICA: Implement depth
//TODO: Make input and output separate colors
//TODO: Make modules at different levels separate colors

//scalastyle:off magic.number
//scalastyle:off regex

/**
  * This library implements a graphviz dot file render.  The annotation can specify at what module to
  * start the rendering process.  value will eventually be modified to allow some options in rendering
  */

/**
  * Tools for creating annotations for direct processing of a firrtl input file.
  */
object VisualizerAnnotation {
  /**
    * Use this to create an firrtl annotation,
    * @param target  The module to start rendering
    * @param depth   Stop rendering after this many sub-modules have been descended. 0 just does IOs of target
    *                1 does all components of current target, plus IOs of submodules referenced,
    *                and so forth.
    * @return
    */
  def apply(target: Named, depth: Int = -1): VisualizerAnnotation = {
    VisualizerAnnotation(target, depth)
  }

  /**
    * Use this to set the program to convert the dot file to a svg.  dot and fdp seem to work well, others
    * might too.  Default is dot
    * @param program program to create png
    * @return
    */
  def setDotProgram(program: String): Annotation = {
    SetRenderProgram(program)
  }

  /**
    * Use this control what program will be called with the png file as its command line argument.
    * On OS-X open will launch the default viewer (usually preview)
    * Set program to none to turn off this feature
    * @param program program to open png
    * @return
    */
  def setOpenProgram(program: String): Annotation = {
    SetOpenProgram(program)
  }

  /**
    * Change the output format generated by dot
    * @param startModule Look for this name in module hierarchy to start graph
    * @return
    */
  def setStartModule(startModule: String): Annotation = {
    StartModule(startModule)
  }
}

case class VisualizerAnnotation(target: Named, depth: Int) extends SingleTargetAnnotation[Named] {
  override def duplicate(n: Named): Annotation = this.copy(target = n)
}

case class VisualizerChiselAnnotation(
  target: InstanceId,
  depth: Int
) extends ChiselAnnotation with RunFirrtlTransform {

  override def toFirrtl: Annotation = VisualizerAnnotation(target.toNamed, depth)

  override def transformClass: Class[_ <: Transform] = classOf[MakeDiagramGroup]
}

trait OptionAnnotation extends NoTargetAnnotation with ChiselAnnotation {
  override def toFirrtl: Annotation = {
    this
  }
}

case class StartModule(startModule: String) extends OptionAnnotation

case class SetRenderProgram(renderProgram: String = "dot") extends OptionAnnotation

case class SetOpenProgram(openProgram: String) extends OptionAnnotation

/**
  * Add this trait to a module to allow user to specify that the module or a submodule should be
  * rendered
  */
trait VisualizerAnnotator {
  self: chisel3.Module =>

  /**
    * Use this to create an firrtl annotation,
    * @param component  The module to start rendering
    * @param depth      Stop rendering after this many sub-modules have been descended. 0 just does IOs of target
    *                   1 does all components of current target, plus IOs of submodules referenced,
    *                   and so forth.
    * @return
    */
  def visualize(component: InstanceId, depth: Int = 0): Unit = {
    experimental.annotate(
      VisualizerChiselAnnotation(component, depth)
    )
  }
  /**
    * Use this to set the program to convert the dot file to a png.  dot and fdp seem to work well, others
    * might too.  Default is dot
    * @param program program to create png
    * @return
    */
  def setDotProgram(program: String): Unit = {
    experimental.annotate(
      SetRenderProgram(program)
    )
  }
  /**
    * Use this control what program will be called with the png file as its command line argument.
    * On OS-X open will launch the default viewer (usually preview)
    * Set program to none to turn off this feature
    * @param program program to open png
    * @return
    */
  def setOpenProgram(program: String): Unit = {
    experimental.annotate(
      SetOpenProgram(program)
    )
  }
}

object FirrtlDiagrammer {

  /**
    * get the target directory from the annotations
    * Do a bit of work to try and avoid inadvertent reference to /
    * @param annotationSeq annotations to search
    * @return
    */
  def getTargetDir(annotationSeq: AnnotationSeq): String = {
    val targetDir = annotationSeq.collectFirst { case x : TargetDirAnnotation => x } match {
      case Some(TargetDirAnnotation(value)) if value.nonEmpty =>
        if(value.endsWith("/")) value else value + "/"
      case _ => "./"
    }
    FileUtils.makeDirectory(targetDir)
    targetDir
  }

  /**
    * Open an svg file using the open program
    * @param fileName    file to be opened
    * @param openProgram program to use
    */
  def show(fileName: String, openProgram: String = "open"): Unit = {
    if(openProgram.nonEmpty && openProgram != "none") {
      val openProcessString = s"$openProgram $fileName.svg"
      openProcessString.!!
    }
  }

  //scalastyle:off method.length
  def render(fileName: String, dotProgram: String = "dot"): Unit = {
    if(dotProgram != "none") {
      //noinspection SpellCheckingInspection
      if(fileName.isEmpty) {
        println(s"Tried to call render program $dotProgram without a filename")
      }
      else if(! new File(fileName).exists() ) {
        println(s"Tried to call render program $dotProgram on non existent file $fileName")
      }
      else {
        val dotProcessString = s"$dotProgram -Tsvg -O $fileName"
        val process = Process(dotProcessString).run()
        val processFuture = Future(blocking(process.exitValue()))
        try {
          Await.result(processFuture, Duration(7, "sec"))
        }
        catch {
          case _: TimeoutException =>
            println(s"Rendering timed out on $fileName with command $dotProcessString")
            process.destroy()
            val printWriter = new PrintWriter(new File(fileName + ".svg"))
            printWriter.print(
              s"""
                |<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
                | "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
                |<!-- Generated by graphviz version 2.40.1 (20161225.0304)
                | -->
                |<!-- Title: TopLevel Pages: 1 -->
                |<svg width="351pt" height="44pt"
                | viewBox="0.00 0.00 351.26 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                |<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
                |<title>TopLevel</title>
                |<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-40 347.2637,-40 347.2637,4 -4,4"/>
                |<!-- Sorry, Rendering timed out on this file, Use Back to return -->
                |<g id="node1" class="node">
                |<title>Sorry, Rendering timed out on this file, Use Back to return</title>
                |<polygon fill="none" stroke="#000000" points="343.3956,-36 -.1319,-36 -.1319,0 343.3956,0 343.3956,-36"/>
                |<text text-anchor="middle" x="171.6318" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">Sorry, Rendering timed out on this file, Use Back to return</text>
                |</g>
                |</g>
                |</svg>
              """.stripMargin)
            printWriter.close()

        }
      }
    }
  }

  def main(args: Array[String]): Unit = {
    val parser = new scopt.OptionParser[Config]("firrtl-diagrammer") {
      head("firrtl-diagrammer", "1.x")

      opt[String]('i', "firrtl-source")
                      .action { (x, c) => c.copy(firrtlSourceFile = x) }
                      .required()
                      .text("must be a valid text file containing firrtl")

      opt[String]('m', "module-name")
              .action { (x, c) => c.copy(startModuleName = x) }
              .text("the module in the hierarchy to start, default is the circuit top")

      opt[String]('t', "target-dir")
              .action { (x, c) => c.copy(targetDir = x) }
              .text("The name of the directory to put dot and svg files")

      opt[String]('o', "open-command")
              .action { (x, c) => c.copy(openProgram = x) }
              .text("The name of the program to open svg file in browser")

      opt[Unit]('j', "just-top-level")
              .action { (_, c) => c.copy(justTopLevel = true) }
              .text("use this to only see the top level view")
    }

    parser.parse(args, Config()) match {
      case Some(config: Config) =>
        val sourceFirrtl = io.Source.fromFile(config.firrtlSourceFile).getLines().mkString("\n")

        val ast = Parser.parse(sourceFirrtl)

        val loweredAst = ToLoFirrtl.lower(ast)

        val targetDir = s"./${loweredAst.main}/"
        FileUtils.makeDirectory(targetDir)

        val printWriter = new PrintWriter(new File(s"$targetDir/styles.css"))
        printWriter.println(
          """
            |.edge:hover * {
            |  stroke: #7fff00;
            |}
            |.edge:hover polygon {
            |  fill: #7fff00;
            |}
          """.stripMargin
        )
        printWriter.close()

        val controlAnnotations = config.toAnnotations

        val circuitState = CircuitState(loweredAst, LowForm, controlAnnotations)

        if(config.justTopLevel) {
          val justTopLevelTransform = new ModuleLevelDiagrammer
          justTopLevelTransform.execute(circuitState)
        }
        else {
          val transform = new MakeDiagramGroup
          transform.execute(circuitState)
        }
      case _ =>
        // bad arguments
    }
  }
}

case class Config(
  firrtlSourceFile: String = "",
  startModuleName:  String = "",
  renderProgram:    String = "dot",
  openProgram:      String = "open",
  targetDir:        String = "",
  justTopLevel:     Boolean = false
) {
  def toAnnotations: Seq[Annotation] = {
    val dir = {
      val baseDir = if(targetDir.isEmpty) {
        firrtlSourceFile.split("/").dropRight(1).mkString("/")
      }
      else {
        targetDir
      }
      if(baseDir.endsWith("/")) baseDir else baseDir + "/"
    }
    Seq(
      SetRenderProgram(renderProgram),
      SetOpenProgram(openProgram),
      TargetDirAnnotation(dir)
    ) ++
    (if(startModuleName.nonEmpty) Seq(StartModule(startModuleName)) else Seq.empty)
  }
}

